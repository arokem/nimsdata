Extending NIMSData
==================

Support for additional varieties of data can be added by creating additional parsers and writers.  New parsers and
writers can be subclassed from the base nimsdata.NIMSReader and nimsdata.NIMSWriter, or from domain specific
base classes, such as nimsdata.medimg.MedImgReader and nimsdata.medimg.MedImgWriter.


NIMSdata input file format
--------------------------

The standard NIMSdata format is a .tar.gz/.tgz file.  The input .tar.gz/.tgz should contain metadata.json, and a
dataset. The json file, metadata.json, should be the first regular file in the archive. The metadata.json file should contain
at least one section sections, 'filetype', and may contain two additional sections, 'header' and 'overwrite'. Filetype
will be used to match the input file to it's parser. The header section is used to define any metadata that is not naturally
part of the dataset.  For example, if a dataset does not contain anything that identifies the data, then identification information
can be added to the header section of metadata.json.  The overwrite section is used to overwrite metadata.  The overwrite section will
overwrite any metadata that is contained in the data, or in the header section of metadata.json.

.. code:: json

    {
     "filetype": "dicom",
     "header":
            {
            "": "",
            "": ""
            },
     "overwrite":
            {
            "": "",
            "": ""
            },
    }


Creating a new NIMSReader
----------------------------

The nimsdata.NIMSReader base class can be subclassed to created additional data readers.

A subclass of nimsdata.NIMSReader must implement the following:

    - __init__ method:

      the init method should call `super` to perform the parent class's __init__ method, which will perform some setup.
      The __init__ function should read one file from the tar archive, and parse metadata that can be collected from a
      single file.  In cases where the input is several files, some information might not be parseable until all the
      inputs have been read in.  __init__ should implement opening the tar archive, and streaming the first file into
      a StringIO/ByteIO/cStringIO file like object in self._hdr.  __init__ should also parse necessary sorting
      information.  __init__ should also be capable of assigning an unique ID to the file, some files may already have
      unique IDs that can be used as the nims unique ID.

      __init__ should invoke the parent class's __init__.

    - load_data method

      load_data should read in all the data files contained within the input .tar.gz/.tgz.  This method should
      parse metadata that requires multiple, or all, input files to be present.  This method should also convert
      data into an intermediate format.

    - nims_group_id property
    - nims_experiment property
    - nims_session_id property
    - nims_session_label property
    - nims_session_subject property
    - nims_epoch_id property
    - nims_epoch_label property
    - nims_epoch_description property
    - nims_file_name property
    - nims_file_ext property
    - nims_file_domain property
    - nims_file_type property
    - nims_file_kind property
    - nims_file_state property
    - nims_timestamp property
    - nims_timezone property


Creating a custom NIMSWriter
----------------------------
The nimsdata.NIMSWriter base class can be subclasses to create additional data readers.

A subclass of nimsdata.NIMSWriter must implement the following:

    - write classmethod:

      The write class method should call super to perform the parent class's write.  The use of super in this case is
      a bit tricky.  NIMSWriter.write does not actually perform a write.  An abstract base class's write
      method performs a "setup" on the writer. A concrete class's implementation of write should call super to
      use the setup, and then write the file.

Other considerations:

    - NIMSWriter appends its own file extension.  It should accept a basename, without extention.


Creating a data domain
----------------------

Readers and Writers can be grouped together based on their data domain.  A domain is similar to a scientific domain, such as
neuro-imaging or genetics.  Readers and writers in the same domain should have an intermediate format that allows "mix-and-matching"
of readers and writers within a domain.

Creating a new data domain involves sublcasses NIMSReader and NIMSWriter into new abstract base classes that define
additional properties, metadata and methods that will be shared within that data domain.

see nimsdata.medimg.medimg for an example of defining a data domain (domain is medical images).
See nimsdata.medimg.nimsdicom for an example of creating a specific reader for a daomain (read dicoms, within medical image domain).

